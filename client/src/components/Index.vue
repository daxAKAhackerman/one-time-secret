<template>
  <b-container>
    <b-row>
      <b-col>
        <h1>One Time Secret</h1>
        <hr />
        <b-collapse v-model="formVisible">
          <b-form-textarea
            v-model="secret"
            rows="20"
            max-rows="20"
          ></b-form-textarea>
          <br />
          <b-row>
            <b-col cols="6">
              <b-form-datepicker
                class="text-left"
                v-model="expirationDate"
                required
                placeholder="Expiration date"
              ></b-form-datepicker>
            </b-col>
            <b-col cols="6">
              <b-form-timepicker
                class="text-left"
                v-model="expirationTime"
                required
                placeholder="Expiration time"
                :hour12="false"
                show-seconds
              ></b-form-timepicker>
            </b-col>
          </b-row>
          <br />
          <b-button @click="postSecret" variant="outline-primary"
            >Create secret link</b-button
          >
          <br />
          <br />
          <h2>How it works</h2>
          <p>
            One Time Secret is an application that allows to securely share
            information using a single-use link. Once the secret has been viewed
            (or once the expiration is reached), the secret is deleted from the
            database and no longer accessible. In addition, the server only has
            access to the encrypted secret and the ID of the secret. Every thing
            else is generated client side and is never sent to the server. More
            precisely:
          </p>
          <ol>
            <li>
              Using JavaScript, a random encryption key and IV are generated and
              used to encrypt the secret.
            </li>
            <li>
              The encrypted secret is sent to the server, along with the
              expiration timestamp.
            </li>
            <li>The server replies with the ID of the secret.</li>
            <li>
              A link is generated by adding the deflated concatenation of the
              ID, encryption key and IV to the hash data of the URL. Hash data
              is not sent to the server when a URL is accessed.
            </li>
            <li>
              When the secret is retreived, the server receives the ID of the
              secret, deletes it from the database, and returns the encrypted
              value back to the client (if it's not expired).
            </li>
            <li>
              The secret value can then be decrypted client side using the
              information stored in the hash data.
            </li>
          </ol>
          <p>
            Want more information? Good news,
            <b-link href="https://github.com/daxAKAhackerman/one-time-secret"
              >this project is open source!
            </b-link>
          </p>
        </b-collapse>
        <b-collapse v-model="linkVisible">
          <div class="secret-link">
            <b-form-textarea
              rows="3"
              no-auto-shrink
              no-resize
              disabled
              v-model="link"
            ></b-form-textarea>
            <b-button
              variant="outline-secondary"
              v-clipboard:copy="link"
              class="copy-button"
              @click="makeToast('Link was copied to clipboard.')"
              ><b-icon-files></b-icon-files
            ></b-button>
          </div>
          <br />
          <b-button variant="outline-secondary" @click="reset"
            >Create an other secret</b-button
          >
        </b-collapse>
        <hr />
      </b-col>
    </b-row>
  </b-container>
</template>

<script>
import axios from "axios";
import pako from "pako";
import crypto from "crypto";

export default {
  name: "Index",
  data() {
    return {
      secret: "",
      expirationDate: new this.$moment().add(7, "days").format("YYYY-MM-DD"),
      expirationTime: "00:00:00",
      link: "",
    };
  },
  computed: {
    expirationTimestamp: function () {
      let expirationTime = this.expirationTime;
      if (!expirationTime) {
        expirationTime = "00:00:00";
      }
      const expiration = `${this.expirationDate} ${expirationTime}`;
      const expirationDate = new Date(expiration);
      const expirationFormated = this.$moment(expirationDate).format("X");

      return expirationFormated;
    },
    formVisible: {
      get: function () {
        return Boolean(!this.link && !location.hash);
      },
      set: function () {},
    },
    linkVisible: {
      get: function () {
        return Boolean(this.link && !location.hash);
      },
      set: function () {},
    },
  },
  methods: {
    generateString(length) {
      let result = "";
      const characters =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

      for (let i = 0; i < length; i++) {
        result += characters.charAt(
          Math.floor(Math.random() * characters.length)
        );
      }

      return result;
    },
    encryptSecret(secret, key, iv) {
      const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
      let encrypted = cipher.update(secret, "utf8", "base64");
      encrypted += cipher.final("base64");

      return encrypted;
    },
    generateLink(uuid, key, iv) {
      const data = encodeURIComponent(
        btoa(
          Array.prototype.map
            .call(pako.deflate(`${uuid};${key};${iv}`), function (ch) {
              return String.fromCharCode(ch);
            })
            .join("")
        )
      );
      console.log(data);
      const link = `${window.location.origin}#${data}`;

      return link;
    },
    postSecret() {
      const path = "/api/secret";

      const key = this.generateString(32);
      const iv = this.generateString(16);
      const secret = this.encryptSecret(this.secret, key, iv);

      const payload = { expiration: this.expirationTimestamp, secret: secret };

      axios
        .post(path, payload)
        .then((response) => {
          this.link = this.generateLink(response.data.id, key, iv);
        })
        .catch((error) => {
          console.error(error);
        });
    },
    makeToast(message) {
      this.$root.$bvToast.toast(message, {
        autoHideDelay: 2000,
        appendToast: false,
        variant: "outline-success",
        noCloseButton: true,
      });
    },
    reset() {
      this.secret = "";
      this.link = "";
    },
  },
};
</script>

<style scoped>
textarea {
  background-color: #edf6ff !important;
}

.copy-button {
  position: absolute;
  bottom: 9%;
  left: 94.8%;
  opacity: 0.25;
  filter: alpha(opacity=25);
  transition: opacity 0.25s ease-in-out;
}

.copy-button:hover {
  opacity: 0.75;
  filter: alpha(opacity=75);
}

.secret-link {
  position: relative;
}
</style>
